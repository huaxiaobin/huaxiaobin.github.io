<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://hyb.life</id>
    <title>HuaYunBin&apos;s Blog</title>
    <updated>2020-03-24T17:06:12.402Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://hyb.life"/>
    <link rel="self" href="https://hyb.life/atom.xml"/>
    <subtitle>Read(); Think(); Try(); Repeat();</subtitle>
    <logo>https://hyb.life/images/avatar.png</logo>
    <icon>https://hyb.life/favicon.ico</icon>
    <rights>All rights reserved 2020, HuaYunBin&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[App接口加密参数破解流程介绍]]></title>
        <id>https://hyb.life/post/app-jia-mi-hermesagent/</id>
        <link href="https://hyb.life/post/app-jia-mi-hermesagent/">
        </link>
        <updated>2020-03-24T03:34:59.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>如今，随着各大公司对数据安全愈发重视，App数据的爬取也变得越来越难。大多数主流App都对自己的数据接口进行了参数的加密，如淘系App的X-sign、抖音系App的X-grogon、拼多多App的anti-token等等，如果请求的时候不携带加密参数，就无法爬取数据。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>如今，随着各大公司对数据安全愈发重视，App数据的爬取也变得越来越难。大多数主流App都对自己的数据接口进行了参数的加密，如淘系App的X-sign、抖音系App的X-grogon、拼多多App的anti-token等等，如果请求的时候不携带加密参数，就无法爬取数据。</p>
</blockquote>
<!-- more -->
<p>这就需要我们对加密函数进行逆向破解，一般流程如下：</p>
<ol>
<li>首先你需要下载App对应的APK文件，对App进行反编译（可见我写的<a href="/post/app-fan-bian-yi-gong-ju-dex2jarjd-gui-de-shi-yong/">App反编译工具使用教程</a>）；</li>
<li>然后你需要找到生成加密参数的函数，这一步往往需要花费较多的时间，很多App都进行了混淆；</li>
<li>对加密函数进行逆向破解，实现自己的加密函数，供数据爬取的时候调用。</li>
</ol>
<p>上面三步，就是一般情况下破解加密函数的流程。然而，往往你会卡在第三步上，你会发现在加密函数中，它又调用了某几个不知名的函数，而你在反编译后的Java代码中还找不到这几个函数的具体实现。这种情况十分多见，如淘宝App加密参数X-sign的生成，这几个不知名的函数往往是隐藏在了so文件中，它直接调用了so文件中的具体实现函数。so文件的破解难度往往很大，加密函数很难找到，就算找到了，也很难分析逆向出来。</p>
<p>这一步也卡了我很久，最后通过参考网上大神们的文章，我知道了一种新的破解思路：</p>
<ol>
<li>首先和一般破解流程一样，你需要对App进行反编译，然后找到生成加密参数的函数；</li>
<li>编写Xposed模块，Hook到该加密函数（可见我写的<a href="/post/xposed-kuang-jia-hook-shi-li-jiao-cheng/">Hook教程</a>）；</li>
<li>Hook到后，把加密函数及实例化后的类对象保存到系统服务中；</li>
<li>在Xposed模块中搭建一个HTTP服务器；</li>
<li>实现一个接口，调用该接口后，通过Java中的反射调用保存到系统服务中的加密函数，返回加密后的参数；</li>
<li>爬虫远程调用该Xposed模块中的接口，实现实时获取加密参数。</li>
</ol>
<p>ps：这一种破解思路，难点在于第三步，如何保存加密函数及实例化后的类对象（因为你的Xposed模块和目标App是两个不用的App，无法实现相互通信），这里可看我的后续文章。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Xposed框架Hook Demo实例教程]]></title>
        <id>https://hyb.life/post/xposed-kuang-jia-hook-shi-li-jiao-cheng/</id>
        <link href="https://hyb.life/post/xposed-kuang-jia-hook-shi-li-jiao-cheng/">
        </link>
        <updated>2020-03-10T06:54:00.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p><code>Xposed</code>是GitHub上rovo89大神设计的一个针对Android平台的动态劫持项目，通过替换/system/bin/app_process程序控制zygote进程，使得app_process在启动过程中会加载XposedBridge.jar这个jar包，从而完成对Zygote进程及其创建的Dalvik虚拟机的劫持。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p><code>Xposed</code>是GitHub上rovo89大神设计的一个针对Android平台的动态劫持项目，通过替换/system/bin/app_process程序控制zygote进程，使得app_process在启动过程中会加载XposedBridge.jar这个jar包，从而完成对Zygote进程及其创建的Dalvik虚拟机的劫持。</p>
</blockquote>
<!-- more -->
<p>Xposed模块本质上也是一个Android App程序，完成一个Xposed模块需要有以下几步：</p>
<ul>
<li>创建一个Android App程序，并让Xposed知道这个程序是一个Xposed模块；</li>
<li>App程序中导入Xposed API的Jar包；</li>
<li>编写具体Hook代码；</li>
<li>添加入口，使Xposed能知道这个Xposed模块的Hook类入口；</li>
</ul>
<h1 id="一-创建app程序并让xposed认识你">一、创建App程序，并让Xposed认识你</h1>
<p>1、打开AndroidStudio，建立一个工程。<br>
<img src="https://hyb.life/post-images/1584525338041.png" alt="" loading="lazy"><br>
<img src="https://hyb.life/post-images/1584525346792.png" alt="" loading="lazy"><br>
2、打开AndroidManifest.xml文件，在文件中添加如下几行代码。</p>
<pre><code class="language-xml">&lt;meta-data
    android:name=&quot;xposeddescription&quot;
    android:value=&quot;Hook Demo程序&quot; /&gt;
&lt;meta-data
    android:name=&quot;xposedminversion&quot;
    android:value=&quot;53&quot; /&gt;
&lt;meta-data
    android:name=&quot;xposedmodule&quot;
    android:value=&quot;true&quot; /&gt;
</code></pre>
<p><img src="https://hyb.life/post-images/1584525775874.png" alt="" loading="lazy"><br>
3、完成以上两步后，就可以在手机上运行测试一下了。把手机连到电脑上，并确定能在AndroidStudio上看到你的手机（看不到就检查下是不是adb的问题），这里我使用了网易MuMu模拟器来代替真机。点击运行，在手机上跳出程序后，打开Xposed软件的模块界面，能看到下面这个，就说明Xposed已经识别到你写的Xposed模块了（<strong>记得把勾选上，开启该模块</strong>）。<br>
<img src="https://hyb.life/post-images/1584544027373.png" alt="" loading="lazy"></p>
<h1 id="二-让你在app程序中能使用xposed-api">二、让你在App程序中能使用Xposed API</h1>
<p>1、打开build.gradle(Module: app)文件，在dependencies中添加如下两行代码，添加后，记得点击右上角的Sync Now按钮，这样我们就可以在我们App程序中使用Xposed的API了。</p>
<pre><code>compileOnly 'de.robv.android.xposed:api:82'
compileOnly 'de.robv.android.xposed:api:82:sources'
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://hyb.life/post-images/1584544629871.png" alt="" loading="lazy"></figure>
<h1 id="三-编写具体hook代码">三、编写具体Hook代码</h1>
<p>1、在编写Hook代码之前，我们首先先完成一个测试的界面：<br>
在activity_main.xml文件中，添加一个按钮，设按钮id为btn；<br>
<img src="https://hyb.life/post-images/1584545266889.png" alt="" loading="lazy"><br>
在MainActivity.java文件中获取该按钮，并绑定点击事件，点击后弹出提示框，内容为方法toastMsg()返回的字符串“我未被劫持”。<br>
<img src="https://hyb.life/post-images/1584545359143.png" alt="" loading="lazy"><br>
重新运行App，点击按钮后效果如下：<br>
<img src="https://hyb.life/post-images/1584545465592.png" alt="" loading="lazy"><br>
2、编写具体Hook代码，这里我们Hook要实现的最终效果是使点击按钮后弹出的提示框内容变为“你被劫持啦”。</p>
<ul>
<li>在MainActivity同级目录下新建HookTest.java文件；</li>
<li>HookTest类实现IXposedHookLoadPackage接口，并重写handleLoadPackage方法；</li>
<li>加判断，当Hook到你需要的应用时，加载需要Hook的类，其中“com.hyb.hookdemo”为目标应用的包名，“com.hyb.hookdemo.MainActivity”为需要Hook的方法的类名，“toastMsg”为需要Hook的方法名；</li>
<li>调用XposedHelpers的findAndHookMethod()方法，方法的第三个参数new XC_MethodHook()为具体的Hook处理逻辑，XC_MethodHook中重写beforeHookedMethod()和afterHookedMethod()两个方法，其中beforeHookedMethod()为toastMsg()方法执行前执行，afterHookedMethod()为toastMsg()方法执行后执行；</li>
<li>在afterHookedMethod()中修改toastMsg()方法的返回值；</li>
</ul>
<p>具体实现代码如下：</p>
<pre><code class="language-java">public class HookTest implements IXposedHookLoadPackage {

    @Override
    public void handleLoadPackage(XC_LoadPackage.LoadPackageParam lpparam) throws Throwable {
        String hookPackageName = &quot;com.hyb.hookdemo&quot;;
        if (hookPackageName.equals(lpparam.packageName)) {
            XposedBridge.log(&quot;已成功Hook到HookDemo应用&quot;);
            Class clazz = lpparam.classLoader.loadClass(&quot;com.hyb.hookdemo.MainActivity&quot;);
            XposedHelpers.findAndHookMethod(clazz, &quot;toastMsg&quot;, new XC_MethodHook() {
                @Override
                protected void beforeHookedMethod(XC_MethodHook.MethodHookParam param) throws Throwable {
                    super.beforeHookedMethod(param);
                }

                @Override
                protected void afterHookedMethod(MethodHookParam param) throws Throwable {
                    param.setResult(&quot;你被劫持啦&quot;);
                }
            });
        }
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://hyb.life/post-images/1584547014109.png" alt="" loading="lazy"></figure>
<h1 id="四-添加入口让xposed知道你的hook模块入口">四、添加入口，让Xposed知道你的Hook模块入口</h1>
<p>1、AndroidStudio左边目录切换到Project目录，在app/src/main上右键选择New-&gt;Folder-&gt;Assets Folder，点击Finish新建。<br>
<img src="https://hyb.life/post-images/1584547671040.png" alt="" loading="lazy"><br>
2、在assets文件夹上新建文件（New-&gt;File），命名为xposed_init，在文件中添加一行文本“com.hyb.hookdemo.HookTest”，该文本为你具体Hook代码文件的完整路径。这样Xposed就可以通过读取xposed_init文件知道你Hook模块的入口在哪啦。<br>
<img src="https://hyb.life/post-images/1584547743775.png" alt="" loading="lazy"></p>
<h1 id="五-最终效果">五、最终效果</h1>
<p>至此，你的Hook模块就完成啦，重新编译运行App，<strong>重启设备（每次修改Hook代码后都记得重启手机）</strong>，点击按钮效果如下：<br>
<img src="https://hyb.life/post-images/1584547950576.png" alt="" loading="lazy"><br>
本次教程就到这里结束啦，最终代码已上传GitHub：<a href="https://github.com/huaxiaobin/HookDemo">https://github.com/huaxiaobin/HookDemo</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux虚拟屏幕Xvfb的介绍]]></title>
        <id>https://hyb.life/post/linux-xu-ni-ping-mu-xvfb-de-jie-shao/</id>
        <link href="https://hyb.life/post/linux-xu-ni-ping-mu-xvfb-de-jie-shao/">
        </link>
        <updated>2020-02-27T17:17:28.000Z</updated>
        <summary type="html"><![CDATA[<p><a href="https://www.x.org/releases/X11R7.6/doc/man/man1/Xvfb.1.xhtml">Xvfb</a>是流行的虚拟现实库，可以使很多需要图形界面的程序虚拟运行；</p>
]]></summary>
        <content type="html"><![CDATA[<p><a href="https://www.x.org/releases/X11R7.6/doc/man/man1/Xvfb.1.xhtml">Xvfb</a>是流行的虚拟现实库，可以使很多需要图形界面的程序虚拟运行；</p>
<!-- more -->
<h2 id="使用原因">使用原因</h2>
<p>淘宝列表页爬取经常会跳滑动验证码，需要使用puppeteer控制浏览器模拟人工滑动，而在无头模式下，无论怎么滑动都无法通过，必须使用有头模式，而CentOS服务器上没有界面，所以只能使用虚拟屏幕，使浏览器运行在虚拟屏幕上。</p>
<h2 id="安装及使用">安装及使用</h2>
<pre><code class="language-shell"># 安装
yum install Xvfb

# 启动  7:虚拟屏幕id，使用时需要用到；  1336x768x24:屏幕分辨率；
Xvfb :7 -screen 0 1336x768x24 2&gt;/dev/null &amp;

# 使用	启动puppeteer程序前需指定运行在哪个虚拟屏幕上，如下命令，运行在虚拟屏幕id为7的上
export DISPLAY=:7
</code></pre>
<h2 id="远程控制-监控">远程控制、监控</h2>
<p>一般情况下，Xvfb都运行在Linux服务器上，你无法看到虚拟屏幕的运行情况，程序的调试十分麻烦，所以你需要在本地远程连接你服务器上所在的虚拟屏幕，进行监控控制。<br>
<strong>服务器端</strong><br>
x11vnc：远程桌面，可以使人远程连接服务器上的虚拟屏幕；</p>
<pre><code class="language-shell"># 安装 ubuntu
sudo apt install x11vnc
# 安装 centos
yum install -y x11vnc

# 启动  5900:连接端口  password:连接密码  7:虚拟屏幕id
x11vnc -listen 0.0.0.0 -rfbport 5900 -noipv6 -passwd password -display :7
</code></pre>
<p><strong>用户端</strong><br>
可以使用vncviewer工具远程连接。</p>
<h2 id="其它">其它</h2>
<p>python有一个第三方库<code>PyVirtualDisplay</code>，该库可以在python程序中启动指定运行端口xvfb程序，并且可远程监听。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[App反编译工具dex2jar、JD-GUI的使用]]></title>
        <id>https://hyb.life/post/app-fan-bian-yi-gong-ju-dex2jarjd-gui-de-shi-yong/</id>
        <link href="https://hyb.life/post/app-fan-bian-yi-gong-ju-dex2jarjd-gui-de-shi-yong/">
        </link>
        <updated>2020-02-27T16:07:04.000Z</updated>
        <summary type="html"><![CDATA[<p>如今爬虫的开发离不开从App爬取数据，本文将介绍如何使用dex2jar反编译一个Android App以及使用JD-GUI工具查看App源码。</p>
]]></summary>
        <content type="html"><![CDATA[<p>如今爬虫的开发离不开从App爬取数据，本文将介绍如何使用dex2jar反编译一个Android App以及使用JD-GUI工具查看App源码。</p>
<!-- more -->
<h2 id="准备工作">准备工作</h2>
<h3 id="dex2jar下载及安装">dex2jar下载及安装</h3>
<p>可以从<a href="https://sourceforge.net/projects/dex2jar/files/">https://sourceforge.net/projects/dex2jar/files/</a>下载dex2jar，然后解压既可。</p>
<h3 id="jd-gui下载及安装">JD-GUI下载及安装</h3>
<p>可以从<a href="http://java-decompiler.github.io/">http://java-decompiler.github.io/</a>下载JD-GUI工具。</p>
<h2 id="反编译">反编译</h2>
<p>首先准备好你所需要编译的Apk文件；</p>
<h3 id="通过dex2jar反编译apk得到jar文件">通过dex2jar反编译Apk得到jar文件</h3>
<pre><code class="language-shell">cd dex2jar-2.x  #首先cd到dex2jar目录下
sh d2j-dex2jar.sh xxx.apk  #执行shell脚本反编译你的Apk
</code></pre>
<p>运行完毕后会在dex2jar目录下生成反编译后的jar文件<br>
ps-1：执行d2j-dex2jar.sh这一步时，可能会报错，如下<br>
<img src="https://hyb.life/post-images/1582821889509.png" alt="" loading="lazy"><br>
这是因为内存溢出的问题，只需要修改d2j-dex2jar.sh脚本中最大所需内存既可，如下，默认为512m，这里改为了4096m<br>
<img src="https://hyb.life/post-images/1582821895545.png" alt="" loading="lazy"><br>
ps-2：还有可能碰到如下错误<br>
<img src="https://hyb.life/post-images/1582822068157.png" alt="" loading="lazy"><br>
这是因为dex2jar版本较老引起得，需要去下载最新版（可能不好找，2.0版本以上）或者自行编译dex2jar源码，然后重新反编译apk既可；<br>
具体编译方法可看<a href="https://github.com/pxb1988/dex2jar/wiki/BuildFromSource">https://github.com/pxb1988/dex2jar/wiki/BuildFromSource</a></p>
<h3 id="使用jd-gui软件查看app源码">使用JD-GUI软件查看App源码</h3>
<p>直接拖动dex2jar生成的jar文件到JD-GUI中既可，如下：<br>
<img src="https://hyb.life/post-images/1582823038881.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
</feed>